 ---
title: "Practical 4: Classification analysis"
author: "Garyfallos Konstantinoudis"
date: "Spring Term 2026"
output:
  pdf_document: default
highlight: tango
---

## Part 1: Predicting treatment outcome for breast cancer based on gene-expression


We look back at the dataset which links gene-expression with the response of breast cancer patients to treatment. Our aim is to build a classifier that can discriminate between 2 responder groups (pathologic complete response or minimal residual cancer burden [RCB-I] defining excellent response (coded as 0), vs moderate or extensive residual cancer burden [RCB-II/III] defining lesser response (coded as 1).

For the original publication please see https://jamanetwork.com/journals/jama/fullarticle/899864

Load the dataset including $n=414$ patients and the predictor matrix including expression of $p=22,283$ genes.
```{r message=FALSE, warning=FALSE}
load("../../data/JAMA2011_breast_cancer")
#alternatively try load("../../data/JAMA2011_breast_cancer.dms")
y = as.factor(data_bc$rcb)
table(y)
x = as.matrix(data_bc$x)
dim(x)
```

Question 1.1

Use the sda package to perform a diagonal discriminant analysis (dda). First we rank the features using the sda.ranking function. The sda package jointly estimates the local fdr. How many genes pass a threshold of local fdr < 0.2?

```{r message=FALSE, warning=FALSE}
library(sda)
```

*Reply: There are 11 genes that pass the local fdr threshold of lower than 0.2.*
```{r message=FALSE, warning=FALSE}
ranking.DDA = sda.ranking(x, y, diagonal=TRUE)
numVarsDDA = sum(ranking.DDA[,"lfdr"]<0.2)
numVarsDDA
selVars = ranking.DDA[,"idx"][1:numVarsDDA]
selVars
```


Question 1.2

Next we use the number of features with local fdr < 0.2 to build a prediction rule for dda and evaluate the prediction rule on the same data (using the same 414 samples as for training the algorithm). How does the confusion matrix (as implemented in the crossval package) look like? What is the sensitivity and specificity of dda?

```{r message=FALSE, warning=FALSE}
library(crossval)
```


*Reply: The sensitivity of dda is 0.7609428 and specificity is 0.6410256 .*
```{r message=FALSE, warning=FALSE}
dda.out = sda(x[, selVars, drop=FALSE], y, diagonal=TRUE)
dda.pred = predict(dda.out, x[, selVars, drop=FALSE], verbose=FALSE)
cM=crossval::confusionMatrix(as.character(y), as.character(dda.pred$class), negative="0")
TPR = cM[2]/(cM[2]+cM[4])
TPR
TNR = cM[3]/(cM[1]+cM[3])
TNR

caret::confusionMatrix(y, dda.pred$class)
?caret::confusionMatrix
caret::confusionMatrix(relevel(dda.pred$class, "1"), relevel(y, "1"))

```


Question 1.3

Compute the area under the curve (AUC) of the receiver operating characteristic (ROC) curve and plot a ROC curve. The package pROC offers the function roc(observed,predicted) which plots the ROC curve and computes the AUC and ROC parameters. Alternatively use the function roc.curve in the PRROC package.

```{r message=FALSE, warning=FALSE}
library(pROC)
library(PRROC)
```

*Reply: AUC is 0.7675. *
```{r message=FALSE, warning=FALSE}
head(dda.pred$posterior)
roc.out=roc(y, dda.pred$posterior[,2])
plot(roc.out)
roc.out$auc
fg = dda.pred$posterior[y==1,2]
bg = dda.pred$posterior[y==0,2]
roc=roc.curve(scores.class0 = fg, scores.class1 = bg, curve = T)
plot(roc, color=FALSE)
```

How to manually calculate a ROC curve. We need for different threshold probabilities to identify a rule and for each of the rules we need to calculate sensitivity and specificity:

```{r message=FALSE, warning=FALSE}
library(dplyr)
data.frame(truth = as.character(y), 
           predicticed = as.character(dda.pred$class), 
           dda.pred$posterior) %>% View()

# for the ROC curve we need to explore the whole prob domain
grid.prob <- seq(from=0, to=1, by = 0.001)
list.loop <- list()

for(i in 1:length(grid.prob)){
  x <- grid.prob[i]
  rule.loop <- ifelse(dda.pred$posterior[,2]<x, 0, 1)
  cM = crossval::confusionMatrix(as.character(y), rule.loop, negative="0")
  TPR = cM[2]/(cM[2]+cM[4])
  TNR = cM[3]/(cM[1]+cM[3])
  list.loop[[i]] <- c(TPR, TNR)
}
ROC.PLOT <- data.frame(do.call(rbind, list.loop))
plot(1-ROC.PLOT$TN, ROC.PLOT$TP, type = "s", pch = 19, cex = 0.5)

do.call(rbind, list.loop) %>% cbind(., grid.prob) %>% View()

##
## put together

plot(1-ROC.PLOT$TN, ROC.PLOT$TP, type = "s", pch = 19, cex = 0.5, col = "red")
plot(roc, color=FALSE, add = TRUE)

```



